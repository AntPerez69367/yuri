/* Auto-generated by cbindgen - DO NOT EDIT */

#ifndef YURI_RS_H
#define YURI_RS_H

#pragma once

/* Warning: This file is auto-generated by cbindgen. */
/* Any manual edits will be overwritten. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Maximum number of meta files that can be loaded
 */
#define META_MAX 20

/**
 * Maximum number of towns supported
 */
#define TOWN_MAX 255

/**
 * Server tick rate in nanoseconds (10ms = 10,000,000 ns)
 * This controls how fast the main server loop runs
 */
#define SERVER_TICK_RATE_NS 10000000

/**
 * Buffer size constants
 */
#define RFIFO_SIZE (16 * 1024)

#define WFIFO_SIZE (16 * 1024)

/**
 * Maximum number of sessions
 */
#define MAX_SESSIONS 1024

/**
 * A point in 3D space (map, x, y)
 *
 * This matches the C struct exactly due to #[repr(C)]
 */
typedef struct Point {
  uint16_t m;
  uint16_t x;
  uint16_t y;
} Point;

/**
 * Load configuration from file (C-compatible entry point)
 *
 * # Safety
 * - `cfg_file` must be a valid null-terminated C string
 * - The pointer must remain valid for the duration of the call
 *
 * Returns 0 on success, -1 on failure
 */
int rust_config_read(const char *cfg_file);

/**
 * Get SQL IP address (returns pointer to static string)
 */
const char *rust_config_get_sql_ip(void);

/**
 * Get SQL port
 */
uint16_t rust_config_get_sql_port(void);

/**
 * Get SQL username
 */
const char *rust_config_get_sql_id(void);

/**
 * Get SQL password
 */
const char *rust_config_get_sql_pw(void);

/**
 * Get SQL database name
 */
const char *rust_config_get_sql_db(void);

/**
 * Get map IP address (as u32 for compatibility with C's inet_addr format)
 */
uint32_t rust_config_get_map_ip(void);

/**
 * Get map port
 */
uint16_t rust_config_get_map_port(void);

/**
 * Get char server IP (as u32)
 */
uint32_t rust_config_get_char_ip(void);

/**
 * Get char server port
 */
uint16_t rust_config_get_char_port(void);

/**
 * Get login server IP (as u32)
 */
uint32_t rust_config_get_login_ip(void);

/**
 * Get login server port
 */
uint16_t rust_config_get_login_port(void);

/**
 * Get XOR encryption key
 */
const char *rust_config_get_xor_key(void);

/**
 * Get start position point (returns by value since Point is #[repr(C)])
 */
struct Point rust_config_get_start_point(void);

/**
 * Get server ID
 */
int rust_config_get_server_id(void);

/**
 * Get number of meta files
 */
int rust_config_get_meta_count(void);

/**
 * Get meta file name by index
 * Returns null if index is out of bounds
 */
const char *rust_config_get_meta_file(int index);

/**
 * Get number of towns
 */
int rust_config_get_town_count(void);

/**
 * Get town name by index
 */
const char *rust_config_get_town_name(int index);

/**
 * Free a string returned by Rust
 * Must be called on all strings returned by rust_config_get_* functions
 *
 * # Safety
 * - `ptr` must be a pointer returned by a rust_config_get_* function
 * - Must only be called once per pointer
 */
void rust_config_free_string(char *ptr);

/**
 * Populate C global variables from Rust config
 * Call this after rust_config_read() to populate the legacy C globals
 *
 * # Safety
 * C global variables must be accessible and have sufficient buffer space
 */
void rust_config_populate_c_globals(void);

/**
 * Initialize the global server state
 * This should be called once at server startup
 */
void rust_core_init(void);

/**
 * Clean up the global server state
 * This should be called at server shutdown
 */
void rust_core_cleanup(void);

/**
 * Set the termination function callback
 * This replaces set_termfunc() from core.c
 *
 * # Safety
 * The callback function pointer must be valid for the lifetime of the server
 * Pass NULL to clear the termination function
 *
 * Note: We use Option<extern "C" fn()> directly here because:
 * 1. In Rust, Option<fn> has guaranteed NULL representation (None = NULL pointer)
 * 2. This is the standard way to represent nullable function pointers in FFI
 * 3. cbindgen will generate the correct C signature
 */
void rust_set_termfunc(void (*func)(void));

/**
 * Handle a signal (called from C signal handlers)
 * This replaces handle_signal() from core.c
 *
 * # Safety
 * Should only be called from signal handlers
 *
 * # Async-signal-safety
 * This function is async-signal-safe - it only sets an atomic flag.
 * The actual shutdown processing happens in rust_should_shutdown()
 * which is called from the main loop.
 */
void rust_handle_signal(int signum);

/**
 * Request server shutdown
 * This should be called by C code to trigger graceful shutdown
 * Equivalent to the old `server_shutdown = 1` pattern
 */
void rust_request_shutdown(void);

/**
 * Check if server shutdown has been requested
 * Returns 1 if shutdown requested, 0 otherwise
 *
 * This function also processes pending shutdown requests from signals.
 * It performs the non-async-signal-safe work (logging, mutex locking,
 * calling termination callbacks) that couldn't be done in the signal handler.
 */
int rust_should_shutdown(void);

/**
 * Get the server tick rate in nanoseconds
 */
uint64_t rust_get_tick_rate_ns(void);

/**
 * Legacy hash generation function (to be replaced)
 */
void rust_generate_hashvalues(const char *name, char *_buffer);

/**
 * Initialize and run the async game server
 * Blocks until server shuts down
 *
 * # Safety
 * Must be called from C main thread
 */
int rust_server_run(uint16_t port);

/**
 * Create a listening socket on the specified port
 * Returns fd on success, -1 on failure
 *
 * Note: In the async model, this is handled by run_async_server
 * This is here for compatibility but may not be used
 */
int rust_make_listen_port(int _port);

/**
 * Create an outgoing connection to ip:port
 * Returns fd on success, -1 on failure
 *
 * TODO: Implement in later task for client connections
 */
int rust_make_connection(uint32_t _ip, int _port);

/**
 * Close a session
 */
int rust_session_eof(int fd);

/**
 * Read unsigned 8-bit value from read buffer
 * Returns 0 if out of bounds or invalid fd
 */
uint8_t rust_session_read_u8(int fd, uintptr_t pos);

/**
 * Read unsigned 16-bit value (little-endian)
 * Returns 0 if out of bounds or invalid fd
 */
uint16_t rust_session_read_u16(int fd, uintptr_t pos);

/**
 * Read unsigned 32-bit value (little-endian)
 * Returns 0 if out of bounds or invalid fd
 */
uint32_t rust_session_read_u32(int fd, uintptr_t pos);

/**
 * Write unsigned 8-bit value to write buffer
 * Returns 0 on success, -1 on error
 */
int rust_session_write_u8(int fd, uintptr_t pos, uint8_t val);

/**
 * Write unsigned 16-bit value (little-endian)
 * Returns 0 on success, -1 on error
 */
int rust_session_write_u16(int fd, uintptr_t pos, uint16_t val);

/**
 * Write unsigned 32-bit value (little-endian)
 * Returns 0 on success, -1 on error
 */
int rust_session_write_u32(int fd, uintptr_t pos, uint32_t val);

/**
 * Skip N bytes in read buffer (like RFIFOSKIP)
 * Returns 0 on success, -1 on error
 */
int rust_session_skip(int fd, uintptr_t len);

/**
 * Get number of unread bytes (like RFIFOREST)
 */
uintptr_t rust_session_available(int fd);

/**
 * Commit write buffer (like WFIFOSET)
 * Returns 0 on success, -1 on error
 */
int rust_session_commit(int fd, uintptr_t len);

/**
 * Flush write buffer - trigger send
 * In async model, writes happen automatically
 * This is a no-op for compatibility
 */
int rust_session_flush(int _fd);

/**
 * Get a raw pointer to the read buffer at offset (like RFIFOP)
 * Returns NULL if fd invalid or out of bounds
 *
 * # Safety
 * The returned pointer is only valid until the next FFI call that modifies the session.
 * Caller must not hold this pointer across other rust_session_* calls.
 */
const uint8_t *rust_session_rdata_ptr(int fd, uintptr_t pos);

/**
 * Get a mutable raw pointer to the write buffer at offset (like WFIFOP)
 * Returns NULL if fd invalid or out of bounds
 *
 * # Safety
 * The returned pointer is only valid until the next FFI call that modifies the session.
 * Caller must call rust_session_commit() after writing.
 */
uint8_t *rust_session_wdata_ptr(int fd, uintptr_t pos);

/**
 * Ensure write buffer has room for `size` bytes (like WFIFOHEAD)
 * Returns 0 on success, -1 on error
 */
int rust_session_wfifohead(int fd, uintptr_t size);

/**
 * Flush read buffer - compact unread data (like RFIFOFLUSH)
 */
int rust_session_rfifoflush(int fd);

/**
 * Set default parse callback for all new sessions
 *
 * # Safety
 * Callback must be a valid C function pointer
 */
void rust_session_set_default_parse(int (*callback)(int));

/**
 * Set default timeout callback
 *
 * # Safety
 * Callback must be a valid C function pointer
 */
void rust_session_set_default_timeout(int (*callback)(int));

/**
 * Set default shutdown callback
 *
 * # Safety
 * Callback must be a valid C function pointer
 */
void rust_session_set_default_shutdown(int (*callback)(int));

#endif  /* YURI_RS_H */
