/* Auto-generated by cbindgen - DO NOT EDIT */

#ifndef YURI_RS_H
#define YURI_RS_H

#pragma once

/* Warning: This file is auto-generated by cbindgen. */
/* Any manual edits will be overwritten. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Maximum number of meta files that can be loaded
 */
#define META_MAX 20

/**
 * Maximum number of towns supported
 */
#define TOWN_MAX 255

/**
 * Server tick rate in nanoseconds (10ms = 10,000,000 ns)
 * This controls how fast the main server loop runs
 */
#define SERVER_TICK_RATE_NS 10000000

/**
 * Non-DDoS entries expire after 3× this interval (ms).
 */
#define DDOS_INTERVAL (3 * 1000)

/**
 * DDoS-locked entries are cleared after this interval (ms).
 */
#define DDOS_AUTORESET ((10 * 60) * 1000)

#define LGN_ERRSERVER 0

#define LGN_WRONGPASS 1

#define LGN_WRONGUSER 2

#define LGN_ERRDB 3

#define LGN_USEREXIST 4

#define LGN_ERRPASS 5

#define LGN_ERRUSER 6

#define LGN_NEWCHAR 7

#define LGN_CHGPASS 8

#define LGN_DBLLOGIN 9

#define LGN_BANNED 10

/**
 * Buffer size constants
 */
#define RFIFO_SIZE (16 * 1024)

#define WFIFO_SIZE (16 * 1024)

/**
 * Maximum number of sessions
 */
#define MAX_SESSIONS 1024

typedef struct BoardData {
  int id;
  int level;
  int gmlevel;
  int path;
  int clan;
  int special;
  int sort;
  char name[64];
  char yname[64];
  /**
   * Single-byte boolean (not a pointer), matches `char script` in C struct.
   */
  char script;
} BoardData;

typedef struct BnData {
  int id;
  char name[255];
} BnData;

typedef struct ClassData {
  /**
   * 16 rank name strings, each 32 bytes (rank0..rank15)
   */
  char ranks[16][32];
  uint16_t id;
  uint16_t path;
  unsigned int level[99];
  int chat;
  int icon;
} ClassData;

typedef struct ClanBank {
  unsigned int item_id;
  unsigned int amount;
  unsigned int owner;
  unsigned int time;
  unsigned int custom_icon;
  unsigned int custom_look;
  unsigned int pos;
  char real_name[64];
  unsigned int custom_look_color;
  unsigned int custom_icon_color;
  unsigned int protected_flag;
  char note[300];
} ClanBank;

typedef struct ClanData {
  int id;
  char name[64];
  int maxslots;
  int maxperslot;
  int level;
  /**
   * Set to null on init; map_loadclanbank() fills this in after init.
   */
  struct ClanBank *clanbanks;
} ClanData;

/**
 * A point in 3D space (map, x, y)
 *
 * This matches the C struct exactly due to #[repr(C)]
 */
typedef struct Point {
  uint16_t m;
  uint16_t x;
  uint16_t y;
} Point;

typedef struct ItemData {
  unsigned int id;
  unsigned int sound;
  unsigned int min_sdam;
  unsigned int max_sdam;
  unsigned int min_ldam;
  unsigned int max_ldam;
  unsigned int sound_hit;
  unsigned int time;
  unsigned int amount;
  char name[64];
  char yname[64];
  char text[64];
  char buytext[64];
  unsigned char typ;
  unsigned char class_;
  unsigned char sex;
  unsigned char level;
  unsigned char icon_color;
  unsigned char ethereal;
  unsigned char unequip;
  int price;
  int sell;
  int rank;
  int stack_amount;
  int look;
  int look_color;
  int dura;
  int might;
  int will;
  int grace;
  int ac;
  int dam;
  int hit;
  int vita;
  int mana;
  int protection;
  int protected_;
  int healing;
  int wisdom;
  int con;
  int attack_speed;
  int icon;
  int mightreq;
  int depositable;
  int exchangeable;
  int droppable;
  int thrown;
  int thrownconfirm;
  int repairable;
  int max_amount;
  int skinnable;
  int bod;
  char *script;
  char *equip_script;
  char *unequip_script;
} ItemData;

typedef struct MagicData {
  int id;
  int typ;
  char name[32];
  char yname[32];
  char question[64];
  char script[64];
  char script2[64];
  char script3[64];
  unsigned char dispell;
  unsigned char aether;
  unsigned char mute;
  unsigned char level;
  unsigned char mark;
  unsigned char canfail;
  char alignment;
  unsigned char ticker;
  char class_;
} MagicData;

/**
 * Mirrors `struct item` from mmo.h (live item instance, not item template).
 * Also used by pc.rs inventory — move to a shared types module when pc.rs is written.
 */
typedef struct MobItem {
  unsigned int id;
  unsigned int owner;
  unsigned int custom;
  unsigned int time;
  int dura;
  int amount;
  unsigned char pos;
  uint8_t _pad[3];
  unsigned int custom_look;
  unsigned int custom_icon;
  unsigned int custom_look_color;
  unsigned int custom_icon_color;
  unsigned int protected_;
  unsigned int traps_table[100];
  unsigned char buytext[64];
  char note[300];
  signed char repair;
  char real_name[64];
} MobItem;

/**
 * Mirrors `struct mobdb_data` from map_server.h.
 * The `equip` array is populated by a MobEquipment sub-query for NPC mobs (mobtype == 1).
 */
typedef struct MobDbData {
  struct MobItem equip[15];
  int vita;
  int type;
  int subtype;
  int look;
  int look_color;
  int hit;
  int level;
  int might;
  int grace;
  int will;
  int movetime;
  int atktime;
  int spawntime;
  int baseac;
  int sound;
  int mana;
  unsigned int owner;
  unsigned int id;
  unsigned int mindam;
  unsigned int maxdam;
  unsigned int exp;
  char name[45];
  char yname[45];
  signed char block;
  signed char retdist;
  unsigned char mobtype;
  signed char state;
  signed char race;
  signed char seeinvis;
  signed char tier;
  unsigned char mark;
  unsigned char isnpc;
  unsigned char isboss;
  short protection;
  short miss;
  unsigned short sex;
  unsigned short face;
  unsigned short face_color;
  unsigned short hair;
  unsigned short hair_color;
  unsigned short armor_color;
  unsigned short skin_color;
  unsigned short startm;
  unsigned short startx;
  unsigned short starty;
} MobDbData;

typedef struct RecipeData {
  int id;
  int tokens_required;
  /**
   * Alternating [material_id, amount] pairs × 5: [mat1, amt1, mat2, amt2, ...]
   */
  int materials[10];
  int superior_materials[2];
  char identifier[64];
  char description[64];
  char crit_identifier[64];
  char crit_description[64];
  unsigned int craft_time;
  unsigned int success_rate;
  unsigned int skill_advance;
  unsigned int crit_rate;
  unsigned int bonus;
  unsigned int skill_required;
} RecipeData;

/**
 * Exposed for C code that declares `extern struct class_data* cdata[20]`.
 * Unused in practice but required by the C headers.
 */
extern struct ClassData *cdata[20];

int rust_boarddb_init(void);

void rust_boarddb_term(void);

struct BoardData *rust_boarddb_search(int id);

struct BoardData *rust_boarddb_searchexist(int id);

unsigned int rust_boarddb_id(const char *s);

char *rust_boarddb_name(int id);

char *rust_boarddb_yname(int id);

int rust_boarddb_level(int id);

int rust_boarddb_gmlevel(int id);

int rust_boarddb_path(int id);

int rust_boarddb_clan(int id);

int rust_boarddb_sort(int id);

/**
 * Returns single-byte boolean (char in C), not a string pointer.
 */
int rust_boarddb_script(int id);

struct BnData *rust_bn_search(int id);

struct BnData *rust_bn_searchexist(int id);

char *rust_bn_name(int id);

int rust_classdb_init(const char *data_dir);

void rust_classdb_term(void);

/**
 * Returns a raw pointer derived from an Arc::into_raw so the ClassData
 * allocation outlives any HashMap clear (e.g. term()). The C caller must
 * not free this pointer directly; call rust_classdb_free when done.
 */
struct ClassData *rust_classdb_search(int id);

struct ClassData *rust_classdb_searchexist(int id);

/**
 * Decrements the Arc reference count for a pointer returned by
 * rust_classdb_search or rust_classdb_searchexist.
 */
void rust_classdb_free(struct ClassData *ptr);

unsigned int rust_classdb_level(int path, int lvl);

/**
 * Returns a caller-owned C string. Must be freed with rust_classdb_free_name().
 */
char *rust_classdb_name(int id, int rank);

/**
 * Frees a string returned by rust_classdb_name.
 */
void rust_classdb_free_name(char *ptr);

int rust_classdb_path(int id);

int rust_classdb_chat(int id);

int rust_classdb_icon(int id);

int rust_clandb_init(void);

void rust_clandb_term(void);

struct ClanData *rust_clandb_search(int id);

struct ClanData *rust_clandb_searchexist(int id);

struct ClanData *rust_clandb_searchname(const char *s);

const char *rust_clandb_name(int id);

/**
 * Load configuration from file (C-compatible entry point)
 *
 * # Safety
 * - `cfg_file` must be a valid null-terminated C string
 * - The pointer must remain valid for the duration of the call
 *
 * Returns 0 on success, -1 on failure
 */
int rust_config_read(const char *cfg_file);

/**
 * Get SQL IP address (returns pointer to static string)
 */
const char *rust_config_get_sql_ip(void);

/**
 * Get SQL port
 */
uint16_t rust_config_get_sql_port(void);

/**
 * Get SQL username
 */
const char *rust_config_get_sql_id(void);

/**
 * Get SQL password
 */
const char *rust_config_get_sql_pw(void);

/**
 * Get SQL database name
 */
const char *rust_config_get_sql_db(void);

/**
 * Get map IP address (as u32 for compatibility with C's inet_addr format)
 */
uint32_t rust_config_get_map_ip(void);

/**
 * Get map port
 */
uint16_t rust_config_get_map_port(void);

/**
 * Get char server IP (as u32)
 */
uint32_t rust_config_get_char_ip(void);

/**
 * Get char server port
 */
uint16_t rust_config_get_char_port(void);

/**
 * Get login server IP (as u32)
 */
uint32_t rust_config_get_login_ip(void);

/**
 * Get login server port
 */
uint16_t rust_config_get_login_port(void);

/**
 * Get XOR encryption key
 */
const char *rust_config_get_xor_key(void);

/**
 * Get start position point (returns by value since Point is #[repr(C)])
 */
struct Point rust_config_get_start_point(void);

/**
 * Get server ID
 */
int rust_config_get_server_id(void);

/**
 * Get number of meta files
 */
int rust_config_get_meta_count(void);

/**
 * Get meta file name by index
 * Returns null if index is out of bounds
 */
const char *rust_config_get_meta_file(int index);

/**
 * Get number of towns
 */
int rust_config_get_town_count(void);

/**
 * Get town name by index
 */
const char *rust_config_get_town_name(int index);

/**
 * Free a string returned by Rust
 * Must be called on all strings returned by rust_config_get_* functions
 *
 * # Safety
 * - `ptr` must be a pointer returned by a rust_config_get_* function
 * - Must only be called once per pointer
 */
void rust_config_free_string(char *ptr);

/**
 * Populate C global variables from Rust config
 * Call this after rust_config_read() to populate the legacy C globals
 *
 * # Safety
 * C global variables must be accessible and have sufficient buffer space
 */
void rust_config_populate_c_globals(void);

/**
 * Initialize the global server state
 * This should be called once at server startup
 */
void rust_core_init(void);

/**
 * Clean up the global server state
 * This should be called at server shutdown
 */
void rust_core_cleanup(void);

/**
 * Set the termination function callback
 * This replaces set_termfunc() from core.c
 *
 * # Safety
 * The callback function pointer must be valid for the lifetime of the server
 * Pass NULL to clear the termination function
 *
 * Note: We use Option<extern "C" fn()> directly here because:
 * 1. In Rust, Option<fn> has guaranteed NULL representation (None = NULL pointer)
 * 2. This is the standard way to represent nullable function pointers in FFI
 * 3. cbindgen will generate the correct C signature
 */
void rust_set_termfunc(void (*func)(void));

/**
 * Handle a signal (called from C signal handlers)
 * This replaces handle_signal() from core.c
 *
 * # Safety
 * Should only be called from signal handlers
 *
 * # Async-signal-safety
 * This function is async-signal-safe - it only sets an atomic flag.
 * The actual shutdown processing happens in rust_should_shutdown()
 * which is called from the main loop.
 */
void rust_handle_signal(int signum);

/**
 * Request server shutdown
 * This should be called by C code to trigger graceful shutdown
 * Equivalent to the old `server_shutdown = 1` pattern
 */
void rust_request_shutdown(void);

/**
 * Check if server shutdown has been requested
 * Returns 1 if shutdown requested, 0 otherwise
 *
 * This function also processes pending shutdown requests from signals.
 * It performs the non-async-signal-safe work (logging, mutex locking,
 * calling termination callbacks) that couldn't be done in the signal handler.
 */
int rust_should_shutdown(void);

/**
 * Get the server tick rate in nanoseconds
 */
uint64_t rust_get_tick_rate_ns(void);

/**
 * Whether the opcode uses dynamic encryption (client-side check).
 */
bool rust_crypt_is_key_client(int opcode);

/**
 * Whether the opcode uses dynamic encryption (server-side check).
 */
bool rust_crypt_is_key_server(int opcode);

/**
 * Generates an MD5 hex digest of `name` into `buffer` (must be ≥33 bytes).
 * Returns `buffer` on success, NULL if buffer too short.
 */
char *rust_crypt_generate_hashvalues(const char *name, char *buffer, int buflen);

/**
 * Builds the 1025-byte encryption lookup table from `name`.
 * Returns `table` on success, NULL on failure.
 */
char *rust_crypt_populate_table(const char *name, char *table, int tablelen);

/**
 * Appends 3 index bytes to `packet` and updates its length field.
 * Returns the new total packet size.
 */
int rust_crypt_set_packet_indexes(unsigned char *packet);

/**
 * Derives a 9-byte session key into `keyout[0..10]` (NUL at [9]).
 * Returns `keyout` on success.
 */
char *rust_crypt_generate_key2(unsigned char *packet,
                               const char *table,
                               char *keyout,
                               int fromclient);

/**
 * XOR-encrypts/decrypts `buff` in-place using a 9-byte `key`.
 */
void rust_crypt_dynamic(unsigned char *buff, const char *key);

/**
 * XOR-encrypts/decrypts `buff` using the static xor_key (passed from C config global).
 */
void rust_crypt_static(unsigned char *buff, const char *xor_key);

/**
 * Called from C's do_init() before any *_init() calls.
 * url format: "mysql://user:pass@host:port/db"
 */
int rust_db_connect(const char *url);

int rust_itemdb_init(void);

void rust_itemdb_term(void);

struct ItemData *rust_itemdb_search(unsigned int id);

struct ItemData *rust_itemdb_searchexist(unsigned int id);

struct ItemData *rust_itemdb_searchname(const char *s);

unsigned int rust_itemdb_id(const char *s);

int rust_itemdb_type(unsigned int id);

char *rust_itemdb_name(unsigned int id);

char *rust_itemdb_yname(unsigned int id);

char *rust_itemdb_text(unsigned int id);

char *rust_itemdb_buytext(unsigned int id);

int rust_itemdb_price(unsigned int id);

int rust_itemdb_sell(unsigned int id);

int rust_itemdb_rank(unsigned int id);

int rust_itemdb_stackamount(unsigned int id);

int rust_itemdb_look(unsigned int id);

int rust_itemdb_lookcolor(unsigned int id);

int rust_itemdb_icon(unsigned int id);

int rust_itemdb_iconcolor(unsigned int id);

unsigned int rust_itemdb_sound(unsigned int id);

unsigned int rust_itemdb_soundhit(unsigned int id);

int rust_itemdb_dura(unsigned int id);

int rust_itemdb_might(unsigned int id);

int rust_itemdb_will(unsigned int id);

int rust_itemdb_grace(unsigned int id);

int rust_itemdb_ac(unsigned int id);

int rust_itemdb_dam(unsigned int id);

int rust_itemdb_hit(unsigned int id);

int rust_itemdb_vita(unsigned int id);

int rust_itemdb_mana(unsigned int id);

int rust_itemdb_protection(unsigned int id);

int rust_itemdb_protected(unsigned int id);

int rust_itemdb_minSdam(unsigned int id);

int rust_itemdb_maxSdam(unsigned int id);

int rust_itemdb_minLdam(unsigned int id);

int rust_itemdb_maxLdam(unsigned int id);

int rust_itemdb_mindam(unsigned int id);

int rust_itemdb_maxdam(unsigned int id);

int rust_itemdb_mincritdam(unsigned int _id);

int rust_itemdb_maxcritdam(unsigned int _id);

int rust_itemdb_mightreq(unsigned int id);

int rust_itemdb_depositable(unsigned int id);

int rust_itemdb_exchangeable(unsigned int id);

int rust_itemdb_droppable(unsigned int id);

int rust_itemdb_thrown(unsigned int id);

int rust_itemdb_thrownconfirm(unsigned int id);

int rust_itemdb_repairable(unsigned int id);

int rust_itemdb_maxamount(unsigned int id);

int rust_itemdb_skinnable(unsigned int id);

int rust_itemdb_unequip(unsigned int id);

int rust_itemdb_ethereal(unsigned int id);

int rust_itemdb_healing(unsigned int id);

int rust_itemdb_wisdom(unsigned int id);

int rust_itemdb_con(unsigned int id);

int rust_itemdb_attackspeed(unsigned int id);

int rust_itemdb_level(unsigned int id);

int rust_itemdb_class(unsigned int id);

int rust_itemdb_sex(unsigned int id);

int rust_itemdb_time(unsigned int id);

char *rust_itemdb_script(unsigned int _id);

char *rust_itemdb_equipscript(unsigned int _id);

char *rust_itemdb_unequipscript(unsigned int _id);

int rust_itemdb_breakondeath(unsigned int id);

int rust_itemdb_reqvita(unsigned int _id);

int rust_itemdb_reqmana(unsigned int _id);

int rust_itemdb_dodge(unsigned int _id);

int rust_itemdb_block(unsigned int _id);

int rust_itemdb_parry(unsigned int _id);

int rust_itemdb_resist(unsigned int _id);

int rust_itemdb_physdeduct(unsigned int _id);

int rust_magicdb_init(void);

void rust_magicdb_term(void);

struct MagicData *rust_magicdb_search(int id);

struct MagicData *rust_magicdb_searchexist(int id);

struct MagicData *rust_magicdb_searchname(const char *s);

int rust_magicdb_id(const char *s);

char *rust_magicdb_name(int id);

char *rust_magicdb_yname(int id);

char *rust_magicdb_question(int id);

int rust_magicdb_type(int id);

int rust_magicdb_dispel(int id);

int rust_magicdb_aether(int id);

int rust_magicdb_mute(int id);

int rust_magicdb_canfail(int id);

int rust_magicdb_alignment(int id);

int rust_magicdb_ticker(int id);

/**
 * Takes spell name string, returns level.
 */
int rust_magicdb_level(const char *s);

/**
 * Script fields are always empty (never populated in original game).
 */
const char *rust_magicdb_script(int _id);

const char *rust_magicdb_script2(int _id);

const char *rust_magicdb_script3(int _id);

int rust_mobdb_init(void);

void rust_mobdb_term(void);

struct MobDbData *rust_mobdb_search(unsigned int id);

struct MobDbData *rust_mobdb_searchexist(unsigned int id);

struct MobDbData *rust_mobdb_searchname(const char *s);

int rust_mobdb_level(unsigned int id);

unsigned int rust_mobdb_experience(unsigned int id);

int rust_mobdb_id(const char *s);

int rust_recipedb_init(void);

void rust_recipedb_term(void);

struct RecipeData *rust_recipedb_search(unsigned int id);

struct RecipeData *rust_recipedb_searchexist(unsigned int id);

struct RecipeData *rust_recipedb_searchname(const char *s);

void rust_register_fd_max_updater(void (*cb)(int));

/**
 * Initialize and run the async game server.
 * Blocks until server shuts down.
 *
 * # Safety
 * Must be called from C main thread after do_init() has registered listeners.
 */
int rust_server_run(uint16_t port);

/**
 * Create a listening socket on the specified port.
 * Returns fd on success, -1 on failure.
 *
 * Binds a std::net::TcpListener (sync, safe from any context) and stores it
 * in the SessionManager. Converted to tokio::net::TcpListener at server start.
 */
int rust_make_listen_port(int port);

/**
 * Create an outgoing connection to ip:port.
 * Returns fd on success, -1 on failure.
 *
 * Safe to call from inside the Tokio runtime (timer callbacks, parse callbacks).
 * The actual TCP connect happens asynchronously in session_io_task after this returns.
 * ip is in network byte order (matching sin_addr.s_addr).
 */
int rust_make_connection(uint32_t ip, int port);

/**
 * Mark a session for closing.
 */
int rust_session_eof(int fd);

/**
 * Read unsigned 8-bit value from read buffer.
 * Returns 0 if out of bounds or session not found.
 */
uint8_t rust_session_read_u8(int fd, uintptr_t pos);

/**
 * Read unsigned 16-bit value (little-endian).
 * Returns 0 if out of bounds or session not found.
 */
uint16_t rust_session_read_u16(int fd, uintptr_t pos);

/**
 * Read unsigned 32-bit value (little-endian).
 * Returns 0 if out of bounds or session not found.
 */
uint32_t rust_session_read_u32(int fd, uintptr_t pos);

/**
 * Write unsigned 8-bit value to write buffer.
 * Returns 0 on success, -1 on error.
 */
int rust_session_write_u8(int fd, uintptr_t pos, uint8_t val);

/**
 * Write unsigned 16-bit value (little-endian).
 * Returns 0 on success, -1 on error.
 */
int rust_session_write_u16(int fd, uintptr_t pos, uint16_t val);

/**
 * Write unsigned 32-bit value (little-endian).
 * Returns 0 on success, -1 on error.
 */
int rust_session_write_u32(int fd, uintptr_t pos, uint32_t val);

/**
 * Skip N bytes in read buffer (like RFIFOSKIP).
 * Returns 0 on success, -1 on error.
 */
int rust_session_skip(int fd, uintptr_t len);

/**
 * Get number of unread bytes (like RFIFOREST).
 */
uintptr_t rust_session_available(int fd);

/**
 * Commit write buffer (like WFIFOSET).
 * Returns 0 on success, -1 on error.
 */
int rust_session_commit(int fd, uintptr_t len);

/**
 * Flush write buffer - no-op in async model (writes happen in session_io_task).
 */
int rust_session_flush(int _fd);

/**
 * Get a raw pointer to the read buffer at offset (like RFIFOP).
 * Returns NULL if fd invalid or out of bounds.
 *
 * # Safety
 * The returned pointer is valid only while the C call stack holds no other FFI calls
 * that could modify this session's read buffer (skip, flush). In practice this is
 * safe because C parse callbacks operate on a single session at a time.
 */
const uint8_t *rust_session_rdata_ptr(int fd, uintptr_t pos);

/**
 * Get a mutable raw pointer to the write buffer at offset (like WFIFOP).
 * Returns NULL if fd invalid or out of bounds.
 *
 * # Safety
 * Caller must call rust_session_commit() after writing to advance wdata_size.
 */
uint8_t *rust_session_wdata_ptr(int fd, uintptr_t pos);

/**
 * Ensure write buffer has room for `size` bytes (like WFIFOHEAD).
 * Returns 0 on success, -1 on error.
 */
int rust_session_wfifohead(int fd, uintptr_t size);

/**
 * Flush read buffer - compact unread data (like RFIFOFLUSH).
 */
int rust_session_rfifoflush(int fd);

/**
 * Set default accept callback — called once per new incoming connection.
 * Use this for initial handshake packets (server speaks first).
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_default_accept(int (*callback)(int));

/**
 * Set default parse callback for all new sessions.
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_default_parse(int (*callback)(int));

/**
 * Set default timeout callback.
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_default_timeout(int (*callback)(int));

/**
 * Set default shutdown callback.
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_default_shutdown(int (*callback)(int));

/**
 * Get session_data pointer (opaque void* for C).
 */
void *rust_session_get_data(int fd);

/**
 * Set session_data pointer.
 */
void rust_session_set_data(int fd, void *data);

/**
 * Get session eof flag.
 */
int rust_session_get_eof(int fd);

/**
 * Set session eof flag.
 */
void rust_session_set_eof(int fd, int eof);

/**
 * Get client IP address as u32 (network byte order, matches sin_addr.s_addr).
 */
uint32_t rust_session_get_client_ip(int fd);

/**
 * Get session increment value (packet sequence counter).
 */
uint8_t rust_session_get_increment(int fd);

/**
 * Increment packet counter and return new value.
 */
uint8_t rust_session_increment(int fd);

/**
 * Check if session exists (returns 1 if exists, 0 if not).
 */
int rust_session_exists(int fd);

/**
 * Override the parse callback for a specific session.
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_parse(int fd, int (*callback)(int));

/**
 * Override the shutdown callback for a specific session.
 *
 * # Safety
 * Callback must be a valid C function pointer.
 */
void rust_session_set_shutdown(int fd, int (*callback)(int));

/**
 * Call the parse callback for a session.
 */
void rust_session_call_parse(int fd);

/**
 * Log a message from C code through Rust's tracing system.
 * level: 0=error, 1=warn, 2=info, 3=debug
 *
 * # Safety
 * msg must be a valid null-terminated C string.
 */
void rust_log_c(int level, const char *msg);

/**
 * Get a snapshot of all active session fds (for iteration in C).
 * Writes fds into caller-provided buffer, returns count written.
 */
int rust_session_get_all_fds(int *buf, int buf_len);

/**
 * Mark an IP as DDoS-locked.
 *
 * `ip` is in network byte order (sin_addr.s_addr), as returned by
 * `rust_session_get_client_ip`.
 */
void rust_add_ip_lockout(uint32_t ip);

/**
 * Timer callback: prune stale DDoS history entries.
 *
 * Registered with timer_insert at server startup (interval 1 s).
 * Signature matches C's `int (*func)(int, int)`.
 */
int rust_connect_check_clear(int _id, int _data);

/**
 * Record a throttled connection attempt from an IP.
 *
 * `ip` is in network byte order (sin_addr.s_addr), as returned by
 * `rust_session_get_client_ip`.
 */
void rust_add_throttle(uint32_t ip);

/**
 * Timer callback: reset all throttle counts.
 *
 * Registered with timer_insert at server startup (interval 10 min).
 * Signature matches C's `int (*func)(int, int)`.
 */
int rust_remove_throttle(int _id, int _data);

/**
 * Get current tick count in milliseconds (monotonic clock)
 */
extern uint32_t gettick_nocache(void);

/**
 * Get current tick count (may be cached)
 */
extern uint32_t gettick(void);

/**
 * Execute all expired timers. Returns ms until next timer fires.
 */
extern int timer_do(uint32_t tick);

/**
 * Initialize timer subsystem (currently a no-op in C)
 */
extern void timer_init(void);

/**
 * Free all timer memory
 */
extern int timer_clear(void);

/**
 * Insert a recurring or one-shot timer.
 * `tick` — initial delay (ms), `interval` — repeat interval (ms, 0 = one-shot),
 * `func` — callback `int (*)(int id, int data)`,
 * `id` / `data` — passed through to callback.
 * Returns a timer handle (used with timer_remove).
 */
extern int timer_insert(uint32_t tick, uint32_t interval, int (*func)(int, int), int id, int data);

#endif  /* YURI_RS_H */
